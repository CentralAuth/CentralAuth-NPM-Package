// This file is auto-generated by @hey-api/openapi-ts
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
export const createSseClient = (_a) => {
    var { onRequest, onSseError, onSseEvent, responseTransformer, responseValidator, sseDefaultRetryDelay, sseMaxRetryAttempts, sseMaxRetryDelay, sseSleepFn, url } = _a, options = __rest(_a, ["onRequest", "onSseError", "onSseEvent", "responseTransformer", "responseValidator", "sseDefaultRetryDelay", "sseMaxRetryAttempts", "sseMaxRetryDelay", "sseSleepFn", "url"]);
    let lastEventId;
    const sleep = sseSleepFn !== null && sseSleepFn !== void 0 ? sseSleepFn : ((ms) => new Promise((resolve) => setTimeout(resolve, ms)));
    const createStream = function () {
        return __asyncGenerator(this, arguments, function* () {
            var _a, _b, _c;
            let retryDelay = sseDefaultRetryDelay !== null && sseDefaultRetryDelay !== void 0 ? sseDefaultRetryDelay : 3000;
            let attempt = 0;
            const signal = (_a = options.signal) !== null && _a !== void 0 ? _a : new AbortController().signal;
            while (true) {
                if (signal.aborted)
                    break;
                attempt++;
                const headers = options.headers instanceof Headers
                    ? options.headers
                    : new Headers(options.headers);
                if (lastEventId !== undefined) {
                    headers.set('Last-Event-ID', lastEventId);
                }
                try {
                    const requestInit = Object.assign(Object.assign({ redirect: 'follow' }, options), { body: options.serializedBody, headers,
                        signal });
                    let request = new Request(url, requestInit);
                    if (onRequest) {
                        request = yield __await(onRequest(url, requestInit));
                    }
                    // fetch must be assigned here, otherwise it would throw the error:
                    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation
                    const _fetch = (_b = options.fetch) !== null && _b !== void 0 ? _b : globalThis.fetch;
                    const response = yield __await(_fetch(request));
                    if (!response.ok)
                        throw new Error(`SSE failed: ${response.status} ${response.statusText}`);
                    if (!response.body)
                        throw new Error('No body in SSE response');
                    const reader = response.body
                        .pipeThrough(new TextDecoderStream())
                        .getReader();
                    let buffer = '';
                    const abortHandler = () => {
                        try {
                            reader.cancel();
                        }
                        catch (_a) {
                            // noop
                        }
                    };
                    signal.addEventListener('abort', abortHandler);
                    try {
                        while (true) {
                            const { done, value } = yield __await(reader.read());
                            if (done)
                                break;
                            buffer += value;
                            const chunks = buffer.split('\n\n');
                            buffer = (_c = chunks.pop()) !== null && _c !== void 0 ? _c : '';
                            for (const chunk of chunks) {
                                const lines = chunk.split('\n');
                                const dataLines = [];
                                let eventName;
                                for (const line of lines) {
                                    if (line.startsWith('data:')) {
                                        dataLines.push(line.replace(/^data:\s*/, ''));
                                    }
                                    else if (line.startsWith('event:')) {
                                        eventName = line.replace(/^event:\s*/, '');
                                    }
                                    else if (line.startsWith('id:')) {
                                        lastEventId = line.replace(/^id:\s*/, '');
                                    }
                                    else if (line.startsWith('retry:')) {
                                        const parsed = Number.parseInt(line.replace(/^retry:\s*/, ''), 10);
                                        if (!Number.isNaN(parsed)) {
                                            retryDelay = parsed;
                                        }
                                    }
                                }
                                let data;
                                let parsedJson = false;
                                if (dataLines.length) {
                                    const rawData = dataLines.join('\n');
                                    try {
                                        data = JSON.parse(rawData);
                                        parsedJson = true;
                                    }
                                    catch (_d) {
                                        data = rawData;
                                    }
                                }
                                if (parsedJson) {
                                    if (responseValidator) {
                                        yield __await(responseValidator(data));
                                    }
                                    if (responseTransformer) {
                                        data = yield __await(responseTransformer(data));
                                    }
                                }
                                onSseEvent === null || onSseEvent === void 0 ? void 0 : onSseEvent({
                                    data,
                                    event: eventName,
                                    id: lastEventId,
                                    retry: retryDelay,
                                });
                                if (dataLines.length) {
                                    yield yield __await(data);
                                }
                            }
                        }
                    }
                    finally {
                        signal.removeEventListener('abort', abortHandler);
                        reader.releaseLock();
                    }
                    break; // exit loop on normal completion
                }
                catch (error) {
                    // connection failed or aborted; retry after delay
                    onSseError === null || onSseError === void 0 ? void 0 : onSseError(error);
                    if (sseMaxRetryAttempts !== undefined &&
                        attempt >= sseMaxRetryAttempts) {
                        break; // stop after firing error
                    }
                    // exponential backoff: double retry each attempt, cap at 30s
                    const backoff = Math.min(retryDelay * Math.pow(2, (attempt - 1)), sseMaxRetryDelay !== null && sseMaxRetryDelay !== void 0 ? sseMaxRetryDelay : 30000);
                    yield __await(sleep(backoff));
                }
            }
        });
    };
    const stream = createStream();
    return { stream };
};
//# sourceMappingURL=serverSentEvents.gen.js.map
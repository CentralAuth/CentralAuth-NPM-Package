// This file is auto-generated by @hey-api/openapi-ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createSseClient } from '../core/serverSentEvents.gen';
import { getValidRequestBody } from '../core/utils.gen';
import { buildUrl, createConfig, createInterceptors, getParseAs, mergeConfigs, mergeHeaders, setAuthParams, } from './utils.gen';
export const createClient = (config = {}) => {
    let _config = mergeConfigs(createConfig(), config);
    const getConfig = () => (Object.assign({}, _config));
    const setConfig = (config) => {
        _config = mergeConfigs(_config, config);
        return getConfig();
    };
    const interceptors = createInterceptors();
    const beforeRequest = (options) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        const opts = Object.assign(Object.assign(Object.assign({}, _config), options), { fetch: (_b = (_a = options.fetch) !== null && _a !== void 0 ? _a : _config.fetch) !== null && _b !== void 0 ? _b : globalThis.fetch, headers: mergeHeaders(_config.headers, options.headers), serializedBody: undefined });
        if (opts.security) {
            yield setAuthParams(Object.assign(Object.assign({}, opts), { security: opts.security }));
        }
        if (opts.requestValidator) {
            yield opts.requestValidator(opts);
        }
        if (opts.body !== undefined && opts.bodySerializer) {
            opts.serializedBody = opts.bodySerializer(opts.body);
        }
        // remove Content-Type header if body is empty to avoid sending invalid requests
        if (opts.body === undefined || opts.serializedBody === '') {
            opts.headers.delete('Content-Type');
        }
        const url = buildUrl(opts);
        return { opts, url };
    });
    const request = (options) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        // @ts-expect-error
        const { opts, url } = yield beforeRequest(options);
        const requestInit = Object.assign(Object.assign({ redirect: 'follow' }, opts), { body: getValidRequestBody(opts) });
        let request = new Request(url, requestInit);
        for (const fn of interceptors.request.fns) {
            if (fn) {
                request = yield fn(request, opts);
            }
        }
        // fetch must be assigned here, otherwise it would throw the error:
        // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation
        const _fetch = opts.fetch;
        let response = yield _fetch(request);
        for (const fn of interceptors.response.fns) {
            if (fn) {
                response = yield fn(response, request, opts);
            }
        }
        const result = {
            request,
            response,
        };
        if (response.ok) {
            const parseAs = (_a = (opts.parseAs === 'auto'
                ? getParseAs(response.headers.get('Content-Type'))
                : opts.parseAs)) !== null && _a !== void 0 ? _a : 'json';
            if (response.status === 204 ||
                response.headers.get('Content-Length') === '0') {
                let emptyData;
                switch (parseAs) {
                    case 'arrayBuffer':
                    case 'blob':
                    case 'text':
                        emptyData = yield response[parseAs]();
                        break;
                    case 'formData':
                        emptyData = new FormData();
                        break;
                    case 'stream':
                        emptyData = response.body;
                        break;
                    case 'json':
                    default:
                        emptyData = {};
                        break;
                }
                return opts.responseStyle === 'data'
                    ? emptyData
                    : Object.assign({ data: emptyData }, result);
            }
            let data;
            switch (parseAs) {
                case 'arrayBuffer':
                case 'blob':
                case 'formData':
                case 'json':
                case 'text':
                    data = yield response[parseAs]();
                    break;
                case 'stream':
                    return opts.responseStyle === 'data'
                        ? response.body
                        : Object.assign({ data: response.body }, result);
            }
            if (parseAs === 'json') {
                if (opts.responseValidator) {
                    yield opts.responseValidator(data);
                }
                if (opts.responseTransformer) {
                    data = yield opts.responseTransformer(data);
                }
            }
            return opts.responseStyle === 'data'
                ? data
                : Object.assign({ data }, result);
        }
        const textError = yield response.text();
        let jsonError;
        try {
            jsonError = JSON.parse(textError);
        }
        catch (_b) {
            // noop
        }
        const error = jsonError !== null && jsonError !== void 0 ? jsonError : textError;
        let finalError = error;
        for (const fn of interceptors.error.fns) {
            if (fn) {
                finalError = (yield fn(error, response, request, opts));
            }
        }
        finalError = finalError || {};
        if (opts.throwOnError) {
            throw finalError;
        }
        // TODO: we probably want to return error and improve types
        return opts.responseStyle === 'data'
            ? undefined
            : Object.assign({ error: finalError }, result);
    });
    const makeMethodFn = (method) => (options) => request(Object.assign(Object.assign({}, options), { method }));
    const makeSseFn = (method) => (options) => __awaiter(void 0, void 0, void 0, function* () {
        const { opts, url } = yield beforeRequest(options);
        return createSseClient(Object.assign(Object.assign({}, opts), { body: opts.body, headers: opts.headers, method, onRequest: (url, init) => __awaiter(void 0, void 0, void 0, function* () {
                let request = new Request(url, init);
                for (const fn of interceptors.request.fns) {
                    if (fn) {
                        request = yield fn(request, opts);
                    }
                }
                return request;
            }), url }));
    });
    return {
        buildUrl,
        connect: makeMethodFn('CONNECT'),
        delete: makeMethodFn('DELETE'),
        get: makeMethodFn('GET'),
        getConfig,
        head: makeMethodFn('HEAD'),
        interceptors,
        options: makeMethodFn('OPTIONS'),
        patch: makeMethodFn('PATCH'),
        post: makeMethodFn('POST'),
        put: makeMethodFn('PUT'),
        request,
        setConfig,
        sse: {
            connect: makeSseFn('CONNECT'),
            delete: makeSseFn('DELETE'),
            get: makeSseFn('GET'),
            head: makeSseFn('HEAD'),
            options: makeSseFn('OPTIONS'),
            patch: makeSseFn('PATCH'),
            post: makeSseFn('POST'),
            put: makeSseFn('PUT'),
            trace: makeSseFn('TRACE'),
        },
        trace: makeMethodFn('TRACE'),
    };
};
//# sourceMappingURL=client.gen.js.map